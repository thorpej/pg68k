GAL22V10
ISATERM

A0 SIZ0   SIZ1   /TEN  /DSACK NC NC NC NC NC NC GND
NC DSACK1 DSACK0  BERR  BEA   NC NC NC NC NC NC VCC

;
; This generate bus termination for ISA bus cycles.  Note that
; we always wire D[31..24] to ISA_D[7..0], and ACK the bus
; cycle based on the size of the request (1 or 2 bytes).  This
; ensures that we can preserve the fidelity of "stream" I/Os.
; Other I/Os (such as 16-bit register accesses) that are not
; simply streaming data from memory must be explicitly byte-
; swapped in software.
;
; Don't bother matching up our requested size vs. the ISA /IO16
; signal; we can't be guaranteed when the device will assert it
; in time to safely generate a bus error.
;
; Truth table:
;
;  TEN  SIZ1  SIZ0  A0  DSACK	===	BERR DSACK1 DSACK0
;    F     x     x   x      x		   F      F      F
;    (longword access -> BERR)
;    T     F     F   x      x              T      F      F
;    (byte access)
;    T     F     T   x      F		   F      F      F
;    T     F     T   x      T              F      F      T
;    (word access - misaligned -> BERR)
;    T     T     F   T      x		   T      F      F
;    T     T     F   F      F		   F      F      F
;    T     T     F   F      T              F      T      F
;    (3 byte access -> BERR)
;    T     T     T   x      x		   T      F      F
;

; XXX BEA (Bus Error Enable) is a "buried signal" because only one
; product term for enables.  It's a NC on the chip.
BEA = TEN * /SIZ1 * /SIZ0
    + TEN *  SIZ1 * /SIZ0 * A0
    + TEN *  SIZ1 *  SIZ0;

BERR.T = GND
BERR.E = BEA;

DSACK1.T = GND;
DSACK1.E = TEN *  SIZ1 * /SIZ0 * /A0 * DSACK;

DSACK0.T = GND;
DSACK0.E = TEN * /SIZ1 *  SIZ0 * DSACK;

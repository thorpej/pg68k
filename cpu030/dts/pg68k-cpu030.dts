/ {
	interrupt-parent = <&intc>;
	#address-cells = <1>;
	#size-cells = <1>;

	model = "Playground 68030 Mk I";
	compatible = "pg68k,cpu030-mk1";

	cpus {
		#address-cells = <1>;
		#size-cells = <0>;

		cpu0: cpu@0 {
			compatible = "motorola,mc68030";
			device_type = "cpu";
			reg = <0>;
			clocks = <&cpu_clk>;
		};
	};

	clocks {
		#address-cells = <0>;
		#size-cells = <0>;

		cpu_clk: osc25M_clk {
			compatible = "fixed-clock";
			#clock-cells = <0>;
			clock-frequency = <25000000>;
		};

		cpu_div4_clk: cpu_div4_clk {
			compatible = "fixed-factor-clock";
			clocks = <&cpu_clk>;
			#clock-cells = <0>;
			clock-mult = <1>;
			clock-div = <4>;
		};

		cpu_div16_clk: cpu_div16_clk {
			compatible = "fixed-factor-clock";
			clocks = <&cpu_clk>;
			#clock-cells = <0>;
			clock-mult = <1>;
			clock-div = <16>;
		};

		uart_clk: osc1_8432M_clk {
			compatible = "fixed-clock";
			#clock-cells = <0>;
			clock-frequency = <1843200>;
		};
	};

	memory@ff800000 {
		compatible = "pg68k,fastmem";
		device_type = "memory";
		reg = <0xff800000 0x00400000>
	};

	obp {
		compatible = "simple-bus";
		#address-cells = <1>;
		#size-cells = <1>;

		intc: interrupt-controller@0xffeffff0 {
			compatible = "pg68k,intc-1";
			reg = <0xffeffff0 0x10>;
			interrupt-controller;
			/*
			 * INTC irq pin interrupt priorities:
			 *
			 *  HIGHEST
			 *  7: ipl 7
			 *  6: ipl 6
			 *  5: ipl 5
			 *  4: ipl 4
			 *  3: ipl 3
			 *  2: ipl 2
			 *  1: ipl 1
			 *  LOWEST
			 *
			 * These are all active-low level-triggered
			 * interrupts.
			 *
			 * INTC cells:
			 * - irq input pin
			 * - interrupt priority level (1-6)
			 * - vector (0 == auto-vector)
			 *
			 * N.B. intc-1 only supports auto-vector interrupts,
			 * and there is a single control input: a global
			 * interrupt enable bit.
			 */
			#interrupt-cells = <3>;
		};

		uart0: serial@0xffe003f8 {	/* ISA-like address */
			compatible = "ns16550a";
			reg = <0xffe003f8 0x8>;
			clocks = <&uart_clk>;
			interrupts = <5 5 0>;
			okay = "yes";
		};

		uart1: serial@0xffe002f8 {	/* ISA-like address */
			compatible = "ns16550a";
			reg = <0xffe002f8 0x8>;
			clocks = <&uart_clk>;
			interrupts = <5 5 0>;
			okay = "yes";
		};

		timer@0xffe00040 {		/* ISA-like address */
			compatible = "pg68k,isactl-timer";
			reg = <0xffe00040 0x8>;
			clocks = <&cpu_div16_clk>;
			interrupts = <6 6 0>;
			okay = "yes";
		};

		ata: ata@0xffe001f0 {		/* ISA-like addresses */
			compatible = "pg68k,atac-1";
			reg = <0xffe001f0 0x8>,	/* command */
			      <0xffe003f6 0x2>;	/* control */
			interrupts = <3 3 0>;
			pio-mode = 0;
			okay = "yes";
		};

		ethernet: ethernet@0xffe00300 {	/* ISA-like address */
			compatible = "realtek,rtl8019as";
			reg = <0xffe00300, 0x20>;
			interrupts = <4 4 0>;
			okay = "yes";
		};

		i2c: i2c@0xffe10000 {
			compatible = "nxp,pcf8584";
			#address-cells = <1>;
			#size-cells = <0>;
			reg = <0xffe10000 0x2>;
			clocks = <&cpu_div4_clk>;
		};

		/*
		 * Another possible i2c controller option
		 * is the NXP PCA9564.  It has its own
		 * internal clock source.  It is not software
		 * compatible with the PCF8584, and operates
		 * at 3.3V instead of 5V.
		 *
		 *	compatible = "nxp,pca9564";
		 *	#address-cells = <1>;
		 *	#size-cells = <0>;
		 *	reg = <0xffe10000 0xx>;
		 */
	};
};
